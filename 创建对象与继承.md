
今天又重新看js高级程序设计中的创建对象与继承，里面写到很多种方法，也提到了各种方法的利弊和改进，特此总结下。
##创建对象
1. 创建单个对象  
创建单个对象，我们通常有两种方式，采用new构造函数创建和对象字面量形式。  
	//采用new 构造函数形式  
	var obj = new Object();  
	//采用对象字面量形式  
	var obj = {};
2. 创建多个对象  
上面方式对于创建多个对象的时候，可能会造成代码的冗余，这时候就想到使用批量创建对象的方式。  

(1). 工厂模式  	
	  
	function createPerson(name, age, job){   
		var person = new Object();  
		person.name = name;  
    		person.age = age;
		person.job = job;
    		person.sayName = function(){
      			alert(this.name);
    		}
    		return person;
	}  

这种方式创建的对象都是object的实例，没有解决对象识别的问题，所以出现使用构造函数方式创建。  

(2). 构造函数模式  

	function Person(name, age, job){
    	this.name = name;
    	this.age = age;
    	this.job = job;
    	this.sayName = function(){
      	alert(this.name);
    	}
  	}

   
  var person = new Person("xiaoming", 23, 'student');
这种模式满足了批量创建多个对象，同时各对象实例不仅是object的实例，同时也是CreatePerson的实例，满足了对象识别，但是创建的多个对象都拥有相同的属性和方法，方法本身作为函数，是对象的一种，在堆内存中实际占有空间，每个对象各自含有一个相同的方法，造成内存的浪费。既然每个对象都拥有一个方法造成空间浪费，可以考虑共享方法。  

	function createPerson(name, age, job){  
  		var person = new Object();
  		person.name = name;
        person.age = age;
        person.job = job;
        person.sayName = sayName;
        return person;
    }
    
    function sayName(){
        alert(this.name);
    }
  
这样子可以满足各个对象的方法共享，但是当多个文件引入时，可能会存在命名冲突等，这样使用原型来创建可以很好的避免。  
(3). 原型模式   
 
    function createPerson(name, age, job){  
  		var person = new Object();
  		person.name = name;
        person.age = age;
        person.job = job;
        person.sayName = sayName;
        return person;
    }
    createPerson.prototype.sayName = fucntion(){
        alert(this.name);
    }



