
今天又重新看js高级程序设计中的创建对象与继承，里面写到很多种方法，也提到了各种方法的利弊和改进，特此总结下。
##创建对象
###1. 创建单个对象  
创建单个对象，我们通常有两种方式，采用new构造函数创建和对象字面量形式。  
	
	//采用new 构造函数形式  
	var obj = new Object();  
	//采用对象字面量形式  
	var obj = {};   
	
###2. 创建多个对象  
上面方式对于创建多个对象的时候，可能会造成代码的冗余，这时候就想到使用批量创建对象的方式。  

(1). 工厂模式  	
	  
	function createPerson(name, age, job){   
		var person = new Object();  
		person.name = name;  
    	person.age = age;
		person.job = job;
    	person.sayName = function(){
      		alert(this.name);
    	}
    	return person;
	}  

这种方式创建的对象都是object的实例，没有解决对象识别的问题，所以出现使用构造函数方式创建。  

(2). 构造函数模式  

	function Person(name, age, job){
    	this.name = name;
    	this.age = age;
    	this.job = job;
    	this.sayName = function(){
      		alert(this.name);
    	}
  	}

   
  var person = new Person("xiaoming", 23, 'student');
这种模式满足了批量创建多个对象，同时各对象实例不仅是object的实例，同时也是CreatePerson的实例，满足了对象识别，但是创建的多个对象都拥有相同的属性和方法，方法本身作为函数，是对象的一种，在堆内存中实际占有空间，每个对象各自含有一个相同的方法，造成内存的浪费。既然每个对象都拥有一个方法造成空间浪费，可以考虑共享方法。  

	function createPerson(name, age, job){  
  	    this.name = name;
    	this.age = age;
    	this.job = job;
        this.sayName = sayName;
    }
    
    function sayName(){
        alert(this.name);
    }
  
这样子可以满足各个对象的方法共享，但是当多个文件引入时，可能会存在命名冲突等，这样使用原型来创建可以很好的避免。  
(3). 原型模式   
 
    function createPerson(name, age, job){  
  		this.name = name;
    	this.age = age;
    	this.job = job;
    }
    createPerson.prototype.sayName = fucntion(){
        alert(this.name);
    }  
上面这种形式为构造函数+原型模式，既可以批量创建对象，同时还可以实现对方法的共享。使用原型模式存在的一个问题是当存在一个引用类型的值的属性时，实例的修改会直接影响其他实例。  

	function CreatePerson(name, age){
		this.name = name;
		this.age = age;
	}
	createPerson.prototype.sayName = function(){
		alert(this.name);
	}
	createPerson.prototype.colors = [red, blue, yellow];  
当我们创建一个实例时，并且修改其colors属性，结果 
 
	var personA = new CreatePerson("xiaoming",26);
	personA.colors.push("pink");
	var personB = new CreatePerson("xiaoli",28);
	console.log(personB.colors) //personB的属性也修改
可见对于引用类型的值，最好将其放置在构造函数中而不是在原型中。
##对象继承
对象的继承无非就是给对象添加一些别的对象的属性，给一个对象添加属性，一方面可以在构造函数中添加继承别的对象的属性，另一方面可以在原型中添加属性。
###1. 原型继承
原型继承通常是将对象的原型对象设置为被继承的实例  

	function Super(name){
		this.name = name;
	}
	Super.prototype.sayName = function(){
		alert(this.name);
	}
	function Sub(education){
		this.education = education
	}
	Sub.prototype = new Super(“xiaoming”);


 



